---
title: "Cardanoのアーキテクチャ"
description: "Cardanoのアーキテクチャ"
lead: ''
date: '2020-10-06 08:48:23 +0000'
lastmod: '2020-10-06 08:48:23 +0000'
draft: false
images: []
---

このセクションでは、Cardano の高レベルのアーキテクチャについて説明します。コア コンポーネントとその相互作用について詳しく説明し、Cardanoの時代と実装について簡単に説明します。

### Cardanoのハイレベルなアーキテクチャ

次の図は、Cardano のシステム コンポーネント間の相互作用の概要を示しています。

![画像](https://ucarecdn.com/3756645a-a4a2-4d2f-846a-e454bf7cba60/)

### システム コンポーネント

Cardanoの現在の実装は高度にモジュール化されています。これには次のコンポーネントが含まれます (展開のユース ケースが異なれば、コンポーネントの組み合わせも異なります)。

- [ノード](https://github.com/input-output-hk/cardano-node)
- [コマンドライン インターフェイス (CLI)](https://github.com/input-output-hk/cardano-node/blob/master/doc/reference/cardano-node-cli-reference.md)
- [ダイダロス ウォレット](https://github.com/input-output-hk/cardano-wallet)
- [Cardano データベース同期](https://github.com/input-output-hk/cardano-db-sync)
- [GraphQL API](https://github.com/input-output-hk/cardano-graphql)サーバー (アポロ)
- [SMASHサーバー](https://github.com/input-output-hk/smash)

### ノードとリモート ノード

ブロックチェーン システムは、システムの状態に関する[コンセンサス](https://docs.cardano.org/core-concepts/consensus-explained)を達成するために相互に通信する、ネットワーク全体に分散された一連のノードで構成されます。

#### ノードは次のことを担当します。

- [ウロボロス](https://github.com/input-output-hk/ouroboros-network/#ouroboros-network)プロトコルの実行
- ブロックの検証と中継
- ブロックの生成 (一部のノード)
- ブロックチェーンの状態に関する情報を他のローカル クライアントに提供する

自分または自分の組織が実行するノードのみを信頼すれば良いです。これが、 [Daedalus](https://docs.cardano.org/cardano-components/daedalus-wallet)がバックグラウンドでノードを実行する理由です。

#### ノードプロセス

Cardanoノードはノードのトップレベルであり、他のサブシステムで構成されています。その中で最も重要なものは、コンセンサス、 [台帳](https://github.com/input-output-hk/cardano-ledger-specs#cardano-ledger)、および補助的な構成、CLI、ロギング、および監視を伴うネットワーキングです。ノード間 IPC プロトコル

ノード間のプロセス間通信 (IPC) プロトコルの目的は、Ouroboros コンセンサス アルゴリズムの一部として、ノード間のブロックとトランザクションの交換を可能にすることです。

ノード間プロトコルは、次の 3 つの「ミニ プロトコル」で構成される複合プロトコルです。

- **chain-sync** : チェーンを追跡し、ブロック ヘッダーを取得するために使用されます。
- **block-fetch** : ブロック本体の取得に使用されます。
- **tx-submission** : 転送トランザクションに使用されます。

これらのミニプロトコルは、ノード間の単一の長期実行伝送制御プロトコル (TCP) 接続で多重化されます。ピアツーピア (P2P) 設定を可能にするために、同じ TCP 接続で双方向に実行できます。

全体的なプロトコル (および各ミニ プロトコル) は、双方がサービス拒否 (DoS) 攻撃から保護する必要があるトラストレス設定向けに設計されています。たとえば、各ミニプロトコルはコンシューマー主導の制御フローを使用するため、ノードは作業をプッシュするのではなく、準備が整ったときにのみ追加の作業を要求します。

プロトコルの設計はモジュール式であり、進化可能です。バージョン ネゴシエーションを使用して、使用するミニ プロトコルのセットに同意します。これにより、互換性の問題を引き起こすことなく、追加または更新されたミニ プロトコルを時間の経過とともに追加できます。

#### ノードからクライアントへの IPC

ノードからクライアントへの IPC プロトコルの目的は、ローカル アプリケーションがノードを介してブロックチェーンと対話できるようにすることです。これには、ウォレット バックエンドやブロックチェーン エクスプローラーなどのアプリケーションが含まれます。ノードからクライアントへのプロトコルにより、これらのアプリケーションは生のチェーン データにアクセスし、現在の台帳の状態を照会できます。また、新しいトランザクションをシステムに送信する機能も提供します。

ノードからクライアントへのプロトコルは、ノードからノードへのプロトコルと同じ設計を使用しますが、ミニプロトコルのセットが異なり、TCP 接続ではなくローカル パイプを使用します。そのため、ノードがネイティブに提供できるもののみを公開する、比較的低レベルの狭いインターフェイスです。たとえば、ノードはすべての生のチェーン データへのアクセスを提供しますが、チェーンのデータをクエリする方法は提供しません。データ サービスとより便利な高レベル API を提供するジョブは、cardano-db-sync やウォレット バックエンドなどの専用クライアントに委任されます。

ノードからクライアントへのプロトコルは、次の 3 つのミニ プロトコルで構成されます。

- **chain-sync** : チェーンをたどり、ブロックを取得するために使用されます
- **local-tx-submission** : トランザクションの送信に使用
- **local-state-query** : 台帳の状態を照会するために使用されます

チェーン同期のノードからクライアントへのバージョンでは、ブロック ヘッダーだけでなく、完全なブロックが使用されます。これが、個別のブロック フェッチ プロトコルが必要ない理由です。 local-tx-submission プロトコルは、ノード間 tx-submission プロトコルに似ていますが、より単純であり、トランザクション検証の失敗の詳細を返します。ローカル状態クエリ プロトコルは、現在の台帳状態へのクエリ アクセスを提供します。これには、チェーン自体に直接反映されていない多くの興味深いデータが含まれています。

[ネットワーク プロトコルの設計と Cardano ノード通信プロトコルの詳細をご覧ください。](https://docs.cardano.org/explore-cardano/cardano-network/networking-protocol)

### コマンドライン インターフェイス (CLI)

ノードの CLI ツールは、システムの「スイス アーミー ナイフ」です。ほぼすべてのことを実行できますが、テキストベースでグラフィカル ユーザー インターフェイス (GUI) がないため、非常に低レベルであり、あまり便利ではありません。

CLI ツールは次のことができます。

- ノードに情報を問い合わせる
- 取引を送信する
- トランザクションの構築と署名
- 暗号鍵の管理

### ダイダロス ウォレット

Daedalus は、ユーザーが自分の ADA を管理するのに役立ち、Cardano ブロックチェーンで支払いを送受信できるフルノード ウォレットです。 Daedalus は、ウォレットのフロントエンドとバックエンドで構成されています。フロントエンドは、ユーザーが表示して操作するグラフィカル アプリケーションです。バックエンドは、ユーザーのウォレットの状態を監視するサービス プロセスであり、コインの選択、トランザクションの構築、提出など、すべての「手間のかかる作業」を行います。バックエンドは、ノードからクライアントへの IPC プロトコルを介してローカル ノードと対話し、HTTP API を介してフロントエンドと対話します。バックエンドは、ウォレットとのやり取りを可能にする CLI も提供します。ウォレットのバックエンドは、API を介して Daedalus なしで単独で使用することもできます。これは、ソフトウェア開発者がカルダノを他のアプリケーションやシステムと統合するための便利な方法です。

Cardano の使用を検討しているほとんどの上級ユーザーは、Daedalus から始めることをお勧めします。

### cardano-db-sync

カルダノ ノードには、ブロックチェーン自体と、ブロックチェーンの検証に必要な関連情報のみが保存されます。この設計原則は、コードの複雑さを最小限に抑え、計算コストとリソースの使用を削減し、ノードのローカル インターフェイスを可能な限り最小限に保ち、外部クライアントを使用してさまざまな便利なインターフェイスと追加機能を提供することに関するものです。特に、ノードはブロックチェーンの履歴情報に対する便利なクエリ インターフェイスを提供しません。このデータ サービスは、構造化照会言語 (SQL) データベースを使用する別のコンポーネントによって提供されます。

詳細を読む:

- Cardano DB Sync とそのコンポーネント
- [スマッシュ](https://docs.cardano.org/cardano-components/smash)

### カルダノの時代と実装について

Cardano は第 3 世代の分散台帳です。これは、世界中の暗号学のトップ研究会議 (国際暗号研究協会第 37 回国際暗号学 CXonference - 暗号 2017) で最初に登場した、査読付きプルーフ オブ ステーク (PoS) ブロックチェーン コンセンサス アルゴリズムである Ouroboros に基づいています。

Cardanoという名前は、複数の時代と実装を経たプラットフォームに付けられた一般的な名前です。これらの概念については、さらに説明が必要です。

#### 時代

カルダノの進化にはいくつかの時代があります。各時代 (バイロン、シェリー、ゴーゲン、芭蕉、ヴォルテール) は、元帳のルールを参照します。たとえば、台帳に保存されるトランザクションの種類とデータ、またはトランザクションの有効性と意味などです。

Cardano メインネットの進化は、Byron 台帳ルール (Byron 時代) から始まりました。メインネットは、2020 年 7 月下旬にバイロン ルールからシェリー レジャー ルールに切り替えるためにハード フォークを行いました。したがって、このハードフォークはシェリー時代の始まりを示しました。

#### 実装

Cardano の最初の実装は、2017 年 9 月に Cardano メインネットの開始時に導入されました。この実装は、Byron 台帳ルールのみをサポートしていました。

その後、カルダノの完全な再実装に着手しました。これにより、2 つの基本的な変更が可能になりました。複数の台帳ルール セットのサポートと、あるルール セットから次のルール セットに切り替えるハード フォーク プロセスの管理です。つまり、新しい実装は Byron ルールと Shelley ルールの両方をサポートできます。つまり、2020 年初頭にメインネットにデプロイされたとき、実装も Byron ルールと完全に互換性がありました。これにより、古い実装から新しい実装へのスムーズな移行が可能になりました。すべてのCardanoユーザーがノードを新しい実装にアップグレードすると、ハードフォークを呼び出してShelleyルールに切り替えることが可能になりました.

3 つ目の Cardano 実装は、Shelley Incentivized Testnet (ITN) で使用されました。このシステムは、Shelley ルールの重要なサブセットをサポートしており、これを使用して、Shelley 委任システムの経済的および社会的ダイナミクスをテストしました。

このカルダノ アーキテクチャの概要は、元のまたは ITN の実装ではなく、メインネットに展開されている現在のCardanoの実装を反映しています。
